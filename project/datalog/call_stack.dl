#ifndef CALL_STACK
#define CALL_STACK

#include "declarations.dl"

// To limit recursion
notContains(nil, id_transfer) :- jump(id_transfer, _, _, _).
notContains([id_1, tail], id_2) :- jump(id_1, _, _, _),
                                   id_1 != id_2,
                                   notContains(tail, id_2),
                                   validStack(tail).

// Whether a stack is valid by itself
validStack(nil).
validStack([id_transfer, nil]) :- jump(id_transfer, _, _, _).
validStack(stack) :- stack = [id_1, [id_2, tail]],
                     jump(id_2, _, blk_fn, _),
                     jump(id_1, blk_src, _, _),
                     blockFollows(blk_src, blk_fn),
                     validStack([id_2, tail]),
                     notContains([id_2, tail], id_1).

// Whether a stack is valid for a block
validBlkStack(blk, nil) :- block(blk).
validBlkStack(blk, stack) :- validStack(stack),
                             stack = [id_transfer, tail],
                             jump(id_transfer, _, blk_fn, _),
                             blockFollows(blk, blk_fn).

// Whether a stack is valid for an ID
validIdStack(id, nil) :- statement(id).
validIdStack(id, stack) :- validBlkStack(blk, stack),
                           blockStmt(blk, id).
validIdStack(id, stack) :- validBlkStack(blk, stack),
                           argument(id, blk, _).

#endif
