#define ENABLE_INPUT_FROM_FILES

.number_type ArgIndex    // Index used to qualify block arguments
.symbol_type Transfer    // ID of a transfer between blocks
.symbol_type Name        // Name associated to an object
.symbol_type SSA         // ID of a statement or block argument and its value
.symbol_type Block       // ID of a basic block

// -- input relations --

// Entry block for a function
.decl function(id_block: Block, name: Name)

// All statements
.decl statement(id: SSA)

// All blocks
.decl block(id_block: Block)

// Associates blocks to contained statements
.decl blockStmt(id_block: Block, id_stmt: SSA)

// An input argument to a block
.decl argument(id_arg: SSA,
               id_block: Block,
               index: ArgIndex)

// Follows relation over statements within single blocks
.decl follows(id_next: SSA, id_prev: SSA)

.decl assign(id: SSA, var_id: SSA)                      // Assignments from var_id to id
.decl const(id: SSA, value: symbol)                     // Constants
.decl uop(id: SSA, id_var: SSA, op: Name)               // Unary operations
.decl bop(id: SSA, id_lhs: SSA, id_rhs: SSA, op: Name)  // Binary operations

.decl load(id: SSA, field: Name)                        // Storage field read
.decl store(id: SSA, field: Name, var_id: SSA)          // Storage field write

// Member access (e.g. msg.sender)
.decl structLoad(id: SSA, id_struct: SSA, field: Name)

// Member access (e.g. someStruct.value = x, not relevant for the project)
.decl structStore(id: SSA, id_struct: SSA, field: Name, id_var: SSA)

// Goto transfer with id `id_transfer` from `id_block_from` to `id_block_to`
.decl goto(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block)

// Conditional branching (think of two Goto's for each true/false branch)
.decl branch(id_transfer_true: Transfer,
             id_transfer_false: Transfer,
             id_block_from: Block,
             id_block_true: Block,
             id_block_false: Block,
             var_cond_id: SSA)  // `var_cond_id` references the condition

// Jump from a block `id_block_from` to a different function with entry block
// `id_block_to` (i.e. a function call). The called function returns to the
// continuation block `id_continuation` of the caller function via return
// transfers.
.decl jump(id_transfer: Transfer,
           id_block_from: Block,
           id_block_to: Block,
           id_continuation: Block)

// Return transfer (note there is no target block; if needed, this can be
// inferred at call sites via the `id_continuation` of the jump transfer).
.decl return(id_transfer: Transfer, id_block_from: Block)

// List of arguments passed in a transfer
.decl transferArgument(id_transfer: Transfer, id_argument_value: SSA, index: ArgIndex)

// Ignore these...
//.decl arrayStore(id: SSA, id_array: SSA, id_index: SSA, id_var: SSA)
//.decl mapStore(id: SSA, id_map: SSA, id_key: SSA, id_var: SSA)
//.decl arrayLoad(id: SSA, id_array: SSA, id_index: SSA)
//.decl mapLoad(id: SSA, id_map: SSA, id_key: SSA)
//.decl call(id_transfer: Transfer, id_block_from: Block, id_block_to: Block, id_continuation: Block)
//.decl unknownBlock(id_block: Block)
.decl selfdestruct(id: SSA, address: SSA)
.decl revert(id_transfer: Transfer, id_block: Block)
.decl builtinVariable(id: SSA, name: symbol)

#ifdef ENABLE_INPUT_FROM_FILES
.input function
.input block
.input blockStmt
.input follows
.input argument
.input statement
.input assign
.input const
.input uop
.input bop
.input load
.input structLoad
.input store
.input structStore
.input goto
.input branch
.input return
.input jump
.input transferArgument
.input selfdestruct
.input revert
.input builtinVariable
// Ignore these...
//.input arrayLoad
//.input mapLoad
//.input arrayStore
//.input mapStore
//.input call
//.input unknownBlock
#endif


// Helper relations
.decl msgSender(id: SSA)
msgSender(id) :- builtinVariable(id, "SENDER").

.decl msgValue(id: SSA)
msgValue(id) :- builtinVariable(id, "VALUE").
// -- output relations --
.decl tainted_sinks(id: SSA)

// Your code goes here...

.decl boolOp(op: Name)  // for operations on boolean values
.decl compOp(op: Name)  // for comparison operations
.decl argTaint(id_block: Block)  // tracks taints of arguments/msg.sender/msg.value accounting for guards
.decl taintedLocal(id: SSA, id_block: Block, src: Name)  // tracks taints for local variables, and args
.decl notGuard(id: SSA)  // NOT a guard, because datalog doesn't like negation loops
.decl permaTainted(field: Name)  // when a global can be tainted forever
.decl taintedGlobal(field: Name, id: SSA, src: Name)  // tracks taints of global vars within a function
.decl firstStmt(id: SSA, id_block: Block)  // first statement of a block
.decl lastStmt(id: SSA, id_block: Block)  // last statement of a block
.decl notFirstStmt(id: SSA, id_block: Block)  // negation of firstStmt for convenience
.decl notLastStmt(id: SSA, id_block: Block)  // negation of lastStmt for convenience
.decl taintedGlobalBlkStart(field: Name, id_block: Block, src: Name)  // tracks taints for global vars at the start of a block
.decl taintedGlobalBlkEnd(field: Name, id_block: Block, src: Name)  // tracks taints for global vars at the end of a block
.decl notEmptyBlock(id_block: Block)  // can be written in datalog, unlike emptyBlock, because it uses existence

// Used in notGuard
boolOp("!").
boolOp("||").
boolOp("&&").

// Used in notGuard
compOp("<").
compOp("<=").
compOp(">").
compOp(">=").
compOp("==").
compOp("!=").

// Virtual taint for tainting untrusted inputs, msg.sender, and msg.value
argTaint(blk) :- function(blk, _).
argTaint(blk) :- goto(_, blk_src, blk), argTaint(blk_src).
argTaint(blk) :- branch(_, __, blk_src, blk, ___, id_cond), notGuard(id_cond), argTaint(blk_src).
argTaint(blk) :- branch(_, __, blk_src, ___, blk, id_cond), notGuard(id_cond), argTaint(blk_src).

// For untrusted inputs, msg.sender, and msg.value
taintedLocal(id, blk, "cond") :- argument(id, blk_fn, _), function(blk_fn, __), argTaint(blk).
taintedLocal(id, blk, "cond") :- msgSender(id), argTaint(blk).
taintedLocal(id, blk, "cond") :- msgValue(id), argTaint(blk).

// For expressions
taintedLocal(id, blk, src) :- assign(id, id_var), taintedLocal(id_var, blk, src).
taintedLocal(id, blk, src) :- uop(id, id_var, _), taintedLocal(id_var, blk, src).
taintedLocal(id, blk, src) :- bop(id, id_lhs, _, _), taintedLocal(id_lhs, blk, src).
taintedLocal(id, blk, src) :- bop(id, _, id_rhs, _), taintedLocal(id_rhs, blk, src).

// For argument combinations
taintedLocal(id, blk, src) :- transferArgument(id_transfer, id_src, idx), taintedLocal(id_src, blk_src, src), argument(id, blk, idx), goto(id_transfer, blk_src, blk).
taintedLocal(id, blk, src) :- transferArgument(id_transfer, id_src, idx), taintedLocal(id_src, blk_src, src), argument(id, blk, idx), branch(id_transfer, _, blk_src, blk, __, ___).
taintedLocal(id, blk, src) :- transferArgument(id_transfer, id_src, idx), taintedLocal(id_src, blk_src, src), argument(id, blk, idx), branch(_, id_transfer, blk_src, __, blk, ___).

// For taints through loads
taintedLocal(id, blk, src) :- load(id, field), blockStmt(blk, id), taintedGlobal(field, id, src).

// For permanent taints, because conditional taints get implicitly passed around by argTaint
taintedLocal(id, blk, "perm") :- goto(_, blk_src, blk), taintedLocal(id, blk_src, "perm").
taintedLocal(id, blk, "perm") :- branch(_, __, blk_src, blk, ___, ____), taintedLocal(id, blk_src, "perm").
taintedLocal(id, blk, "perm") :- branch(_, __, blk_src, ___, blk, ____), taintedLocal(id, blk_src, "perm").

// Used for passing around taintedGlobal
firstStmt(id, blk) :- blockStmt(blk, id), !notFirstStmt(id, blk).
lastStmt(id, blk) :- blockStmt(blk, id), !notLastStmt(id, blk).
notFirstStmt(id, blk) :- blockStmt(blk, id), blockStmt(blk, id_src), follows(id, id_src).
notLastStmt(id, blk) :- blockStmt(blk, id), blockStmt(blk, id_src), follows(id_src, id).
notEmptyBlock(blk) :- blockStmt(blk, _).

// taintedGlobal rules for block start/end
taintedGlobal(field, id, src) :- taintedGlobalBlkStart(field, blk, src), firstStmt(id, blk).
taintedGlobalBlkEnd(field, blk, src) :- taintedGlobal(field, id, src), lastStmt(id, blk).
taintedGlobalBlkEnd(field, blk, src) :- taintedGlobalBlkStart(field, blk, src), !notEmptyBlock(blk).

// Apply taintedGlobal when storing
taintedGlobal(field, id, src) :- store(id, field, id_var), taintedLocal(id_var, blk, src), blockStmt(blk, id).

// Apply perma-taint when loading perma-tainted globals
taintedGlobal(field, id, "perm") :- permaTainted(field), firstStmt(id, blk), function(blk, _).

// Pass taintedGlobal b/w statements
taintedGlobal(field, id, src) :- taintedGlobal(field, id_src, src), follows(id, id_src), !store(id, field, _).

// Pass taintedGlobal for each id for transfers
taintedGlobalBlkStart(field, blk, "perm") :- goto(_, blk_src, blk), taintedGlobalBlkEnd(field, blk_src, "perm").
taintedGlobalBlkStart(field, blk, "perm") :- branch(_, __, blk_src, blk, ___, ____), taintedGlobalBlkEnd(field, blk_src, "perm").
taintedGlobalBlkStart(field, blk, "perm") :- branch(_, __, blk_src, ___, blk, ____), taintedGlobalBlkEnd(field, blk_src, "perm").
taintedGlobalBlkStart(field, blk, "cond") :- goto(_, blk_src, blk), taintedGlobalBlkEnd(field, blk_src, "cond"), argTaint(blk).
taintedGlobalBlkStart(field, blk, "cond") :- branch(_, __, blk_src, blk, ___, ____), taintedGlobalBlkEnd(field, blk_src, "cond"), argTaint(blk).
taintedGlobalBlkStart(field, blk, "cond") :- branch(_, __, blk_src, ___, blk, ____), taintedGlobalBlkEnd(field, blk_src, "cond"), argTaint(blk).

// Save perma-taints when returning
permaTainted(field) :- return(_, blk), taintedGlobalBlkEnd(field, blk, "perm").
permaTainted(field) :- return(_, blk), taintedGlobalBlkEnd(field, blk, "cond"), argTaint(blk).

// Base guard definition
notGuard(id) :- const(id, "True").
notGuard(id) :- const(id, "False").
notGuard(id) :- assign(id, _).
notGuard(id) :- bop(id, id_lhs, id_rhs, op), compOp(op), msgSender(id_lhs), taintedLocal(id_rhs, blk, _), !msgSender(id_rhs), blockStmt(blk, id).
notGuard(id) :- bop(id, id_lhs, id_rhs, op), compOp(op), taintedLocal(id_lhs, blk, _), !msgSender(id_lhs), msgSender(id_rhs), blockStmt(blk, id).
notGuard(id) :- bop(id, id_lhs, id_rhs, op), compOp(op), !msgSender(id_lhs), !msgSender(id_rhs).

// Combination of guards within a require/if-else
notGuard(id) :- uop(id, id_var, op), boolOp(op), notGuard(id_var).
notGuard(id) :- bop(id, id_lhs, _, op), boolOp(op), notGuard(id_lhs), taintedLocal(id_lhs, blk, __), blockStmt(blk, id).
notGuard(id) :- bop(id, _, id_rhs, op), boolOp(op), notGuard(id_rhs), taintedLocal(id_rhs, blk, __), blockStmt(blk, id).
notGuard(id) :- bop(id, id_lhs, id_rhs, op), boolOp(op), notGuard(id_lhs), notGuard(id_rhs).

// Final output
tainted_sinks(id) :- selfdestruct(id, addr), taintedLocal(addr, blk, _), blockStmt(blk, id).

.output tainted_sinks
